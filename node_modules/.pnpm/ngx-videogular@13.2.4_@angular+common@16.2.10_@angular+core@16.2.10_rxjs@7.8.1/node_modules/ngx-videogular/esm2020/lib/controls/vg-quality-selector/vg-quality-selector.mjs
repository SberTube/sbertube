import { Component, Input, ViewEncapsulation, Output, EventEmitter } from '@angular/core';
import * as i0 from "@angular/core";
import * as i1 from "../../core/services/vg-api";
import * as i2 from "@angular/common";
// tslint:disable:no-output-on-prefix
// tslint:disable:component-class-suffix
// tslint:disable:no-string-literal
export class VgQualitySelector {
    constructor(ref, API) {
        this.API = API;
        this.onBitrateChange = new EventEmitter();
        this.subscriptions = [];
        this.elem = ref.nativeElement;
    }
    ngOnInit() {
    }
    ngOnChanges(changes) {
        if (changes['bitrates'].currentValue && changes['bitrates'].currentValue.length) {
            this.bitrates.forEach(item => item.label = (item.label || Math.round(item.bitrate / 1000)).toString());
        }
    }
    selectBitrate(index) {
        this.bitrateSelected = this.bitrates[index];
        this.onBitrateChange.emit(this.bitrates[index]);
    }
    ngOnDestroy() {
        this.subscriptions.forEach(s => s.unsubscribe());
    }
}
VgQualitySelector.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.2.2", ngImport: i0, type: VgQualitySelector, deps: [{ token: i0.ElementRef }, { token: i1.VgAPI }], target: i0.ɵɵFactoryTarget.Component });
VgQualitySelector.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.2.2", type: VgQualitySelector, selector: "vg-quality-selector", inputs: { bitrates: "bitrates" }, outputs: { onBitrateChange: "onBitrateChange" }, usesOnChanges: true, ngImport: i0, template: `
        <div class="container">
            <div class="quality-selected"
                 [class.vg-icon-hd]="!bitrateSelected">
                {{ bitrateSelected?.label }}
            </div>

            <select class="quality-selector"
                    (change)="selectBitrate($event.target.value)"
                    tabindex="0"
                    aria-label="quality selector"
                    [attr.aria-valuetext]="ariaValue">
                <option
                    *ngFor="let bitrate of bitrates"
                    [value]="bitrate.qualityIndex.toString()"
                    [selected]="bitrate.qualityIndex === bitrateSelected?.qualityIndex">
                    {{ bitrate.label }}
                </option>
            </select>
        </div>
    `, isInline: true, styles: ["vg-quality-selector{-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;display:flex;justify-content:center;width:50px;height:50px;cursor:pointer;color:#fff;line-height:50px}vg-quality-selector .container{position:relative;display:flex;flex-grow:1;align-items:center;padding:0;margin:5px}vg-quality-selector select.quality-selector{width:50px;padding:5px 8px;border:none;background:none;-webkit-appearance:none;-moz-appearance:none;appearance:none;color:transparent;font-size:16px}vg-quality-selector select.quality-selector::-ms-expand{display:none}vg-quality-selector select.quality-selector option{color:#000}vg-quality-selector .quality-selected{position:absolute;width:100%;height:50px;top:-6px;text-align:center;text-transform:uppercase;font-family:Helvetica Neue,Helvetica,Arial,sans-serif;padding-top:2px;pointer-events:none}vg-quality-selector .vg-icon-closed_caption:before{width:100%}\n"], directives: [{ type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }], encapsulation: i0.ViewEncapsulation.None });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.2.2", ngImport: i0, type: VgQualitySelector, decorators: [{
            type: Component,
            args: [{
                    selector: 'vg-quality-selector',
                    encapsulation: ViewEncapsulation.None,
                    template: `
        <div class="container">
            <div class="quality-selected"
                 [class.vg-icon-hd]="!bitrateSelected">
                {{ bitrateSelected?.label }}
            </div>

            <select class="quality-selector"
                    (change)="selectBitrate($event.target.value)"
                    tabindex="0"
                    aria-label="quality selector"
                    [attr.aria-valuetext]="ariaValue">
                <option
                    *ngFor="let bitrate of bitrates"
                    [value]="bitrate.qualityIndex.toString()"
                    [selected]="bitrate.qualityIndex === bitrateSelected?.qualityIndex">
                    {{ bitrate.label }}
                </option>
            </select>
        </div>
    `,
                    styles: [`
        vg-quality-selector {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            display: flex;
            justify-content: center;
            width: 50px;
            height: 50px;
            cursor: pointer;
            color: white;
            line-height: 50px;
        }
        vg-quality-selector .container {
            position: relative;
            display: flex;
            flex-grow: 1;
            align-items: center;

            padding: 0;
            margin: 5px;
        }
        vg-quality-selector select.quality-selector {
            width: 50px;
            padding: 5px 8px;
            border: none;
            background: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            color: transparent;
            font-size: 16px;
        }
        vg-quality-selector select.quality-selector::-ms-expand {
            display: none;
        }
        vg-quality-selector select.quality-selector option {
            color: #000;
        }
        vg-quality-selector .quality-selected {
            position: absolute;
            width: 100%;
            height: 50px;
            top: -6px;
            text-align: center;
            text-transform: uppercase;
            font-family: Helvetica Neue, Helvetica, Arial, sans-serif;
            padding-top: 2px;
            pointer-events: none;
        }
        vg-quality-selector .vg-icon-closed_caption:before {
            width: 100%;
        }
    `]
                }]
        }], ctorParameters: function () { return [{ type: i0.ElementRef }, { type: i1.VgAPI }]; }, propDecorators: { bitrates: [{
                type: Input
            }], onBitrateChange: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmctcXVhbGl0eS1zZWxlY3Rvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL25neC12aWRlb2d1bGFyL3NyYy9saWIvY29udHJvbHMvdmctcXVhbGl0eS1zZWxlY3Rvci92Zy1xdWFsaXR5LXNlbGVjdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxTQUFTLEVBR1QsS0FBSyxFQUNMLGlCQUFpQixFQUdOLE1BQU0sRUFBRSxZQUFZLEVBQ2hDLE1BQU0sZUFBZSxDQUFDOzs7O0FBTXZCLHFDQUFxQztBQUNyQyx3Q0FBd0M7QUFDeEMsbUNBQW1DO0FBa0ZuQyxNQUFNLE9BQU8saUJBQWlCO0lBYzVCLFlBQVksR0FBZSxFQUFTLEdBQVU7UUFBVixRQUFHLEdBQUgsR0FBRyxDQUFPO1FBWHBDLG9CQUFlLEdBQWdDLElBQUksWUFBWSxFQUFFLENBQUM7UUFPNUUsa0JBQWEsR0FBbUIsRUFBRSxDQUFDO1FBS2pDLElBQUksQ0FBQyxJQUFJLEdBQUcsR0FBRyxDQUFDLGFBQWEsQ0FBQztJQUNoQyxDQUFDO0lBRUQsUUFBUTtJQUNSLENBQUM7SUFFRCxXQUFXLENBQUMsT0FBc0I7UUFDaEMsSUFBSSxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUMsWUFBWSxJQUFJLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFO1lBQy9FLElBQUksQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQztTQUN4RztJQUNILENBQUM7SUFFRCxhQUFhLENBQUMsS0FBYTtRQUN6QixJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDNUMsSUFBSSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0lBQ2xELENBQUM7SUFFRCxXQUFXO1FBQ1QsSUFBSSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztJQUNuRCxDQUFDOzs4R0FsQ1UsaUJBQWlCO2tHQUFqQixpQkFBaUIsbUtBOUVsQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FvQlA7MkZBMERRLGlCQUFpQjtrQkFqRjdCLFNBQVM7bUJBQUM7b0JBQ1QsUUFBUSxFQUFFLHFCQUFxQjtvQkFDL0IsYUFBYSxFQUFFLGlCQUFpQixDQUFDLElBQUk7b0JBQ3JDLFFBQVEsRUFBRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FvQlA7b0JBQ0gsTUFBTSxFQUFFLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0F1RE4sQ0FBRTtpQkFDTjtxSEFFVSxRQUFRO3NCQUFoQixLQUFLO2dCQUVJLGVBQWU7c0JBQXhCLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDb21wb25lbnQsXG4gIEVsZW1lbnRSZWYsXG4gIE9uSW5pdCxcbiAgSW5wdXQsXG4gIFZpZXdFbmNhcHN1bGF0aW9uLFxuICBPbkRlc3Ryb3ksXG4gIFNpbXBsZUNoYW5nZXMsXG4gIE9uQ2hhbmdlcywgT3V0cHV0LCBFdmVudEVtaXR0ZXJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBWZ0FQSSB9IGZyb20gJy4uLy4uL2NvcmUvc2VydmljZXMvdmctYXBpJztcbmltcG9ydCB7IFN1YnNjcmlwdGlvbiB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgQml0cmF0ZU9wdGlvbiB9IGZyb20gJy4uLy4uL2NvcmUvdmctY29yZS5tb2R1bGUnO1xuXG5cbi8vIHRzbGludDpkaXNhYmxlOm5vLW91dHB1dC1vbi1wcmVmaXhcbi8vIHRzbGludDpkaXNhYmxlOmNvbXBvbmVudC1jbGFzcy1zdWZmaXhcbi8vIHRzbGludDpkaXNhYmxlOm5vLXN0cmluZy1saXRlcmFsXG5AQ29tcG9uZW50KHtcbiAgc2VsZWN0b3I6ICd2Zy1xdWFsaXR5LXNlbGVjdG9yJyxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRhaW5lclwiPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInF1YWxpdHktc2VsZWN0ZWRcIlxuICAgICAgICAgICAgICAgICBbY2xhc3MudmctaWNvbi1oZF09XCIhYml0cmF0ZVNlbGVjdGVkXCI+XG4gICAgICAgICAgICAgICAge3sgYml0cmF0ZVNlbGVjdGVkPy5sYWJlbCB9fVxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDxzZWxlY3QgY2xhc3M9XCJxdWFsaXR5LXNlbGVjdG9yXCJcbiAgICAgICAgICAgICAgICAgICAgKGNoYW5nZSk9XCJzZWxlY3RCaXRyYXRlKCRldmVudC50YXJnZXQudmFsdWUpXCJcbiAgICAgICAgICAgICAgICAgICAgdGFiaW5kZXg9XCIwXCJcbiAgICAgICAgICAgICAgICAgICAgYXJpYS1sYWJlbD1cInF1YWxpdHkgc2VsZWN0b3JcIlxuICAgICAgICAgICAgICAgICAgICBbYXR0ci5hcmlhLXZhbHVldGV4dF09XCJhcmlhVmFsdWVcIj5cbiAgICAgICAgICAgICAgICA8b3B0aW9uXG4gICAgICAgICAgICAgICAgICAgICpuZ0Zvcj1cImxldCBiaXRyYXRlIG9mIGJpdHJhdGVzXCJcbiAgICAgICAgICAgICAgICAgICAgW3ZhbHVlXT1cImJpdHJhdGUucXVhbGl0eUluZGV4LnRvU3RyaW5nKClcIlxuICAgICAgICAgICAgICAgICAgICBbc2VsZWN0ZWRdPVwiYml0cmF0ZS5xdWFsaXR5SW5kZXggPT09IGJpdHJhdGVTZWxlY3RlZD8ucXVhbGl0eUluZGV4XCI+XG4gICAgICAgICAgICAgICAgICAgIHt7IGJpdHJhdGUubGFiZWwgfX1cbiAgICAgICAgICAgICAgICA8L29wdGlvbj5cbiAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICA8L2Rpdj5cbiAgICBgLFxuICBzdHlsZXM6IFtgXG4gICAgICAgIHZnLXF1YWxpdHktc2VsZWN0b3Ige1xuICAgICAgICAgICAgLXdlYmtpdC10b3VjaC1jYWxsb3V0OiBub25lO1xuICAgICAgICAgICAgLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgICAgIC1tb3otdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgICAgICAtbXMtdXNlci1zZWxlY3Q6IG5vbmU7XG4gICAgICAgICAgICB1c2VyLXNlbGVjdDogbm9uZTtcbiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcbiAgICAgICAgICAgIHdpZHRoOiA1MHB4O1xuICAgICAgICAgICAgaGVpZ2h0OiA1MHB4O1xuICAgICAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xuICAgICAgICAgICAgY29sb3I6IHdoaXRlO1xuICAgICAgICAgICAgbGluZS1oZWlnaHQ6IDUwcHg7XG4gICAgICAgIH1cbiAgICAgICAgdmctcXVhbGl0eS1zZWxlY3RvciAuY29udGFpbmVyIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICAgICAgICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgICAgICAgICBmbGV4LWdyb3c6IDE7XG4gICAgICAgICAgICBhbGlnbi1pdGVtczogY2VudGVyO1xuXG4gICAgICAgICAgICBwYWRkaW5nOiAwO1xuICAgICAgICAgICAgbWFyZ2luOiA1cHg7XG4gICAgICAgIH1cbiAgICAgICAgdmctcXVhbGl0eS1zZWxlY3RvciBzZWxlY3QucXVhbGl0eS1zZWxlY3RvciB7XG4gICAgICAgICAgICB3aWR0aDogNTBweDtcbiAgICAgICAgICAgIHBhZGRpbmc6IDVweCA4cHg7XG4gICAgICAgICAgICBib3JkZXI6IG5vbmU7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiBub25lO1xuICAgICAgICAgICAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xuICAgICAgICAgICAgLW1vei1hcHBlYXJhbmNlOiBub25lO1xuICAgICAgICAgICAgYXBwZWFyYW5jZTogbm9uZTtcbiAgICAgICAgICAgIGNvbG9yOiB0cmFuc3BhcmVudDtcbiAgICAgICAgICAgIGZvbnQtc2l6ZTogMTZweDtcbiAgICAgICAgfVxuICAgICAgICB2Zy1xdWFsaXR5LXNlbGVjdG9yIHNlbGVjdC5xdWFsaXR5LXNlbGVjdG9yOjotbXMtZXhwYW5kIHtcbiAgICAgICAgICAgIGRpc3BsYXk6IG5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgdmctcXVhbGl0eS1zZWxlY3RvciBzZWxlY3QucXVhbGl0eS1zZWxlY3RvciBvcHRpb24ge1xuICAgICAgICAgICAgY29sb3I6ICMwMDA7XG4gICAgICAgIH1cbiAgICAgICAgdmctcXVhbGl0eS1zZWxlY3RvciAucXVhbGl0eS1zZWxlY3RlZCB7XG4gICAgICAgICAgICBwb3NpdGlvbjogYWJzb2x1dGU7XG4gICAgICAgICAgICB3aWR0aDogMTAwJTtcbiAgICAgICAgICAgIGhlaWdodDogNTBweDtcbiAgICAgICAgICAgIHRvcDogLTZweDtcbiAgICAgICAgICAgIHRleHQtYWxpZ246IGNlbnRlcjtcbiAgICAgICAgICAgIHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG4gICAgICAgICAgICBmb250LWZhbWlseTogSGVsdmV0aWNhIE5ldWUsIEhlbHZldGljYSwgQXJpYWwsIHNhbnMtc2VyaWY7XG4gICAgICAgICAgICBwYWRkaW5nLXRvcDogMnB4O1xuICAgICAgICAgICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XG4gICAgICAgIH1cbiAgICAgICAgdmctcXVhbGl0eS1zZWxlY3RvciAudmctaWNvbi1jbG9zZWRfY2FwdGlvbjpiZWZvcmUge1xuICAgICAgICAgICAgd2lkdGg6IDEwMCU7XG4gICAgICAgIH1cbiAgICBgIF1cbn0pXG5leHBvcnQgY2xhc3MgVmdRdWFsaXR5U2VsZWN0b3IgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcbiAgQElucHV0KCkgYml0cmF0ZXM6IEJpdHJhdGVPcHRpb25bXTtcblxuICBAT3V0cHV0KCkgb25CaXRyYXRlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8Qml0cmF0ZU9wdGlvbj4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgYml0cmF0ZVNlbGVjdGVkOiBCaXRyYXRlT3B0aW9uO1xuXG4gIGVsZW06IEhUTUxFbGVtZW50O1xuICB0YXJnZXQ6IGFueTtcblxuICBzdWJzY3JpcHRpb25zOiBTdWJzY3JpcHRpb25bXSA9IFtdO1xuXG4gIGFyaWFWYWx1ZTogc3RyaW5nIHwgbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKHJlZjogRWxlbWVudFJlZiwgcHVibGljIEFQSTogVmdBUEkpIHtcbiAgICB0aGlzLmVsZW0gPSByZWYubmF0aXZlRWxlbWVudDtcbiAgfVxuXG4gIG5nT25Jbml0KCkge1xuICB9XG5cbiAgbmdPbkNoYW5nZXMoY2hhbmdlczogU2ltcGxlQ2hhbmdlcykge1xuICAgIGlmIChjaGFuZ2VzWydiaXRyYXRlcyddLmN1cnJlbnRWYWx1ZSAmJiBjaGFuZ2VzWydiaXRyYXRlcyddLmN1cnJlbnRWYWx1ZS5sZW5ndGgpIHtcbiAgICAgIHRoaXMuYml0cmF0ZXMuZm9yRWFjaChpdGVtID0+IGl0ZW0ubGFiZWwgPSAoaXRlbS5sYWJlbCB8fCBNYXRoLnJvdW5kKGl0ZW0uYml0cmF0ZSAvIDEwMDApKS50b1N0cmluZygpKTtcbiAgICB9XG4gIH1cblxuICBzZWxlY3RCaXRyYXRlKGluZGV4OiBudW1iZXIpIHtcbiAgICB0aGlzLmJpdHJhdGVTZWxlY3RlZCA9IHRoaXMuYml0cmF0ZXNbaW5kZXhdO1xuICAgIHRoaXMub25CaXRyYXRlQ2hhbmdlLmVtaXQodGhpcy5iaXRyYXRlc1tpbmRleF0pO1xuICB9XG5cbiAgbmdPbkRlc3Ryb3koKSB7XG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLmZvckVhY2gocyA9PiBzLnVuc3Vic2NyaWJlKCkpO1xuICB9XG59XG4iXX0=